---
{"dg-publish":true,"permalink":"/cybersecurity/02-pentesting/d10-04-mar/active-reconnaissance/active-reconnaissance/"}
---


[Access the lab](https://tryhackme.com/room/activerecon)

---
Active reconnaissance involves directly interacting with the target to gather information. This can include making phone calls, visiting the organization under a false pretense (often as part of social engineering), or establishing a connection with the target system—such as accessing their website or probing for open ports like SSH. It’s similar to closely inspecting a building’s windows and door locks. Because this type of activity involves direct engagement, it is critical to obtain signed legal authorization from the client before proceeding.

![attachments/Pasted image 20250605150614.png](/img/user/Cybersecurity/02_Pentesting/D10_04%20Mar/Active%20Reconnaissance/attachments/Pasted%20image%2020250605150614.png)
### Task 2 - Web Browser

A web browser is a handy tool for gathering information about a target, as it's readily available on all systems. There are multiple ways to leverage a browser for reconnaissance.

At the transport layer, browsers connect to:
- TCP port 80 by default when accessing websites via HTTP
- TCP port 443 by default when accessing websites via HTTPS
    

These default ports are typically hidden in the browser's address bar. However, custom ports can be used to access services. For example, the URL `https://127.0.0.1:8834/` connects to the local host (`127.0.0.1`) using port `8834` over HTTPS. If an HTTPS service is running on that port, the browser will display its web page.

While viewing a web page, you can open Developer Tools by pressing **Ctrl + Shift + I** on Windows or **Option + Command + I (⌥ + ⌘ + I)** on macOS in Firefox. Similar shortcuts work for Chrome and Chromium browsers. Developer Tools allow you to explore various elements exchanged between your browser and the web server. You can inspect and even modify JavaScript files, examine cookies set on your machine, and explore the folder structure of the website.

There are numerous browser add-ons available for Firefox and Chrome that can assist with penetration testing. Here are a few notable examples:

- **FoxyProxy**: This extension allows you to easily switch between different proxy servers when accessing a target website. It's especially useful when working with tools like Burp Suite or when frequently changing proxy configurations. FoxyProxy is available for Firefox.
    
- **User-Agent Switcher and Manager**: This tool lets you modify your browser’s user-agent string, allowing you to simulate access from a different device or browser. For example, you can make it appear as though you're visiting a site from an iPhone while actually using Firefox. You can install this add-on for Firefox.
    
- **Wappalyzer**: This extension identifies the technologies used by the websites you visit, such as content management systems, analytics tools, and frameworks. It’s particularly helpful for silently gathering technology stack details while browsing like a regular user. A screenshot of Wappalyzer is shown below, and it is also available for Firefox.

![attachments/Pasted image 20250605151445.png](/img/user/Cybersecurity/02_Pentesting/D10_04%20Mar/Active%20Reconnaissance/attachments/Pasted%20image%2020250605151445.png)

![attachments/Pasted image 20250605151519.png](/img/user/Cybersecurity/02_Pentesting/D10_04%20Mar/Active%20Reconnaissance/attachments/Pasted%20image%2020250605151519.png)![attachments/Pasted image 20250605151530.png](/img/user/Cybersecurity/02_Pentesting/D10_04%20Mar/Active%20Reconnaissance/attachments/Pasted%20image%2020250605151530.png)


### **Task 3**

### PING
Think of the `ping` command like a game of ping-pong—you send something out and expect it to bounce back. Its main role is to test if a remote system is reachable and responsive, much like checking if a doorbell rings and someone answers. Originally designed for testing basic network connectivity, `ping` is now commonly used in reconnaissance to verify if a target system is online.

At its core, the `ping` command sends a data packet (specifically, an ICMP Echo Request) to a remote system. If that system is up, and nothing along the path blocks the packet, it responds with an ICMP Echo Reply. When both systems can communicate without interference from firewalls or routing issues, you’ll get a reply confirming the target is online and accessible.

For instance, from your **AttackBox terminal**, you can use:
`ping MACHINE_IP`

Or, if you're pinging a domain name:
`ping HOSTNAME`

In this case, the system resolves the hostname to an IP address before sending packets. On **Linux**, the ping command continues until manually stopped with `CTRL+C`, unless you specify a packet count using `-c`, like:
`ping -c 10 MACHINE_IP`

On **Windows**, the equivalent would be:
`ping -n 10 MACHINE_IP`

Technically, this falls under the **ICMP protocol (Internet Control Message Protocol)**, specifically using type 8 (echo request) and type 0 (echo reply). Although understanding every ICMP type isn't necessary, knowing these two is useful.

In a working example:
`ping -c 5 MACHINE_IP`

The output shows replies with minimal delay and no packet loss, confirming that the machine is online and reachable. For example:

- 5 packets sent, 5 received
- 0% packet loss
- Average response time: 0.475 ms
    

### But what happens if the system is offline?

Suppose you shut down the target VM and then run:
`ping -c 5 MACHINE_IP`

You’d see messages like:
`Destination Host Unreachable`

and:

- 5 packets sent, 0 received
- 100% packet loss

This response means your system couldn’t reach the target. Common reasons include:

- The system is off, booting up, or has crashed.
- It’s disconnected from the network or experiencing network failure.
- A firewall is blocking ICMP requests (Windows does this by default).
- Your own system might not be connected to the network.
    

In short, if `ping` replies are received, the target is likely online. If not, you’ve got some sleuthing to do—network issues, firewalls, or power states may be the culprits.
![attachments/Pasted image 20250605151837.png](/img/user/Cybersecurity/02_Pentesting/D10_04%20Mar/Active%20Reconnaissance/attachments/Pasted%20image%2020250605151837.png)
![attachments/Pasted image 20250605152232.png](/img/user/Cybersecurity/02_Pentesting/D10_04%20Mar/Active%20Reconnaissance/attachments/Pasted%20image%2020250605152232.png)


### **Task 4**

The `traceroute` command, as its name implies, is used to trace the path that packets take from your system to a target host. Its main goal is to identify the IP addresses of all routers (also known as hops) that the packet passes through on its journey. This can also help determine how many hops exist between the source and destination systems. It's a valuable tool for understanding the route your traffic is taking, although the path may vary due to dynamic routing protocols that adapt in real-time to network conditions.

On **Linux** and **macOS**, you use:
`traceroute 10.10.211.28`

On **Windows**, the equivalent command is:
`tracert 10.10.211.28`

The traceroute process works by using the **TTL (Time To Live)** field in the IP header. Despite the name, TTL doesn't represent time, but rather the **maximum number of hops** a packet can take before it's discarded. Every time a packet reaches a router, the TTL is reduced by 1. If the TTL reaches 0, the packet is dropped, and the router typically sends back an **ICMP "Time Exceeded"** message to the sender.

For example, if a packet leaves your system with a TTL of 64 and reaches the destination with a TTL of 60, this indicates that it passed through 4 routers.

Here's how `traceroute` exploits this behavior:

- It first sends a packet with TTL=1. The first router drops it and returns an ICMP error.
- It then sends another with TTL=2, which the second router drops, and so on.
- This process continues until the packet reaches the final destination, revealing the IP addresses of each router along the way.
    

It's worth noting that not all routers respond to these ICMP errors—some may silently drop packets instead.

When run from a system like TryHackMe’s **AttackBox**, the output of a command like:
`traceroute tryhackme.com`

may vary across multiple runs due to changes in network routing. This variability is expected, especially on networks that use dynamic routing protocols.
In summary, here are the key observations:

- The number of hops or routers between your system and the target can vary depending on when you run the `traceroute` command. Packet routes are not fixed and may change, even if you're on the same network or repeat the command shortly after.
    
- Some routers along the path will respond with a public IP address. Depending on your penetration testing scope, these IPs may be worth further investigation.
    
- Certain routers may not respond at all, providing no reply during the trace.
![attachments/Pasted image 20250605152819.png](/img/user/Cybersecurity/02_Pentesting/D10_04%20Mar/Active%20Reconnaissance/attachments/Pasted%20image%2020250605152819.png)

![attachments/Pasted image 20250605152826.png](/img/user/Cybersecurity/02_Pentesting/D10_04%20Mar/Active%20Reconnaissance/attachments/Pasted%20image%2020250605152826.png)

![attachments/Pasted image 20250605152835.png](/img/user/Cybersecurity/02_Pentesting/D10_04%20Mar/Active%20Reconnaissance/attachments/Pasted%20image%2020250605152835.png)


![attachments/Pasted image 20250605152954.png](/img/user/Cybersecurity/02_Pentesting/D10_04%20Mar/Active%20Reconnaissance/attachments/Pasted%20image%2020250605152954.png)


!!! thus task 4 is done.

### **Task 5**

The TELNET (Teletype Network) protocol, introduced in 1969, was designed to allow users to access remote systems through a command-line interface (CLI). The `telnet` command uses this protocol for remote administration, typically connecting over TCP port 23. However, from a security standpoint, TELNET is highly insecure because it transmits all data—including usernames and passwords—in plain text, making it easy for attackers with access to the communication channel to intercept sensitive information. SSH (Secure Shell) is the more secure alternative for remote access.

Despite its security flaws, the telnet client is still useful for other tasks due to its simplicity and reliance on the TCP protocol. For instance, it can be used to connect to any TCP-based service and retrieve basic information, such as a service banner. By running `telnet 10.10.211.28 PORT`, you can connect to a service on a specific port and even exchange unencrypted messages if supported.

Suppose you want to gather details from a web server running on port 80. You can connect using Telnet and communicate using HTTP. After connecting, type `GET / HTTP/1.1` to request the default index page, or use a specific path like `GET /page.html HTTP/1.1` to request a particular file. Since you're using HTTP 1.1, you also need to specify the `Host` header—for example, `Host: example`—and press Enter twice. This approach allows you to retrieve a valid HTTP response from the web server.

![attachments/Pasted image 20250605153202.png](/img/user/Cybersecurity/02_Pentesting/D10_04%20Mar/Active%20Reconnaissance/attachments/Pasted%20image%2020250605153202.png)

![attachments/Pasted image 20250605153311.png](/img/user/Cybersecurity/02_Pentesting/D10_04%20Mar/Active%20Reconnaissance/attachments/Pasted%20image%2020250605153311.png)

### **Task 6**
Netcat, commonly referred to as `nc`, is a versatile tool with numerous applications that are particularly useful for penetration testers. It supports both TCP and UDP protocols and can operate in two modes: as a client that initiates connections to specified ports, or as a server that listens on a chosen port. This makes Netcat an excellent utility for quickly setting up simple client-server communications over either protocol.

One common use case is banner grabbing—similar to what can be done with Telnet. You can connect to a remote server using the command `nc 10.10.211.28 PORT` to interact with a service and retrieve its banner. This works similarly to the Telnet example (`telnet 10.10.211.28 PORT`). When sending HTTP requests, you might need to press **SHIFT + ENTER** after the `GET` line to ensure the command is correctly processed.

In the terminal output above, we used Netcat (`nc`) to initiate a connection to the IP address `10.10.211.28` on port `80` with the command:
`nc 10.10.211.28 80`

Once connected, we sent an HTTP request using:
`GET / HTTP/1.1 host: netcat`

This tells the web server we want the default homepage (`/`) using HTTP version 1.1. The `host:` header, while required for a proper request in HTTP/1.1, can be given any value (in this case, "netcat") and doesn't affect functionality here.

The response we received includes:
`Server: nginx/1.6.2`

This reveals that the server is running **Nginx version 1.6.2** on port 80. This kind of manual banner grabbing is one way Netcat helps identify running services and versions.

---

Netcat is not only useful for connecting to services—it can also **listen for incoming connections**, functioning like a lightweight server.

To set this up on a machine that will _receive_ the connection (the "server"), use:
`nc -vnlp 1234`

This command breaks down as follows:

|Option|Description|
|---|---|
|`-v`|Verbose output (helpful for debugging)|
|`-n`|Numeric IP addresses only (skip DNS resolution)|
|`-l`|Listen mode (waits for incoming connections)|
|`-p`|Specifies the port to listen on (`1234` in this case)|

> 💡 Ports below 1024 require elevated privileges (root access) to bind to.

Then, on a different machine (the "client"), you connect with:
`nc 10.10.211.28 1234`

Once the connection is established, **anything typed on one side will appear on the other**—a basic bidirectional TCP tunnel. This is often used for quick data transfer, reverse shells, or setting up temporary communication channels during penetration testing.

> [!summary]
> In summary, Netcat is a powerful and flexible utility, capable of both initiating and accepting network connections over TCP or UDP, making it invaluable for pentesters and network professionals alike.

![attachments/Pasted image 20250605153759.png](/img/user/Cybersecurity/02_Pentesting/D10_04%20Mar/Active%20Reconnaissance/attachments/Pasted%20image%2020250605153759.png)

In this module, we explored several foundational tools that, when combined, can serve as the building blocks for a basic network and system scanner. By using simple shell scripts, you can automate tasks such as:

- Mapping the network route using `traceroute`
- Checking host availability with `ping`
- Probing ports using `telnet` or `netcat`
    

While these methods are quite rudimentary compared to the sophisticated scanning techniques employed by tools like **Nmap** (which we'll explore in upcoming modules), they remain effective for quick, low-level reconnaissance.

Here's a summary of the commands we covered:

|Tool|Example Usage|
|---|---|
|`ping` (Linux/macOS)|`ping -c 10 10.10.211.28`|
|`ping` (Windows)|`ping -n 10 10.10.211.28`|
|`traceroute` (Linux/macOS)|`traceroute 10.10.211.28`|
|`tracert` (Windows)|`tracert 10.10.211.28`|
|`telnet`|`telnet 10.10.211.28 PORT_NUMBER`|
|`netcat` (client)|`nc 10.10.211.28 PORT_NUMBER`|
|`netcat` (server)|`nc -lvnp PORT_NUMBER`|

Even though these utilities are basic, they’re almost universally available across different operating systems and are valuable for initial recon activities. Additionally, your **web browser**—which exists on virtually all devices—is a surprisingly powerful tool for passive reconnaissance. By leveraging the **Developer Tools**, you can inspect requests, responses, headers, and much more without triggering alarms on the target system.

To open Developer Tools in a browser:

|Operating System|Shortcut|
|---|---|
|Linux/Windows|`Ctrl + Shift + I`|
|macOS|`Option + Command + I`|